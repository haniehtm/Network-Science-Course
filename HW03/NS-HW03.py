# -*- coding: utf-8 -*-
"""Untitled49.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FVln_wEIbhYHmiRSvtT1E2dDDz8OfIb9
"""

import networkx as nx
import random
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm
import scipy.stats as stats


def generate_random_graph(n, avg_degree):
    # ساخت گراف خالی
    my_graph = nx.Graph()

    # حساب کردن کل یال‌ها با استفاده از متوسط یال‌ها
    total_edges = int((avg_degree * n) / 2)

    # چینش یال‌ها و اضافه کردن شرط عدم تکرار
    edges = set()
    while len(edges) < total_edges:
        u, v = random.sample(range(n), 2)
        if u != v:
            edges.add((u, v))

    my_graph.add_edges_from(edges)

    return my_graph

def degree_distribution(my_graph):
    degrees = dict(my_graph.degree())
    degree_values = list(degrees.values())
    degree_counts = [degree_values.count(d) for d in set(degree_values)]

    num_nodes = len(degree_values)
    pmf = [count / num_nodes for count in degree_counts]

    return list(set(degree_values)), degree_counts , pmf

def neighbor_degree_distribution(my_graph, node):
    neighbor_degrees = [my_graph.degree(neighbor) for neighbor in my_graph.neighbors(node)]
    neighbor_degree_values = list(neighbor_degrees)
    neighbor_degree_counts = [neighbor_degree_values.count(d) for d in set(neighbor_degree_values)]

    return list(set(neighbor_degree_values)), neighbor_degree_counts

def main():
    num_nodes = int(input("Enter the desired number of nodes for your graph: "))
    avg_degree = int(input("Enter the desired average number of edges for your graph: "))
    my_graph = generate_random_graph(num_nodes, avg_degree)

    degrees, counts , pmf = degree_distribution(my_graph)
    min_degree = min(degrees)
    max_degree = max(degrees)
    index_min = degrees.index(min_degree)
    index_max = degrees.index(max_degree)

    print("\nGraph Info:")
    print("Number of Nodes:", num_nodes)
    print("Average Degree:", avg_degree)
    print("Min Degree:", min_degree, "which is for", index_min ,"th node")
    print("Max Degree:", max_degree, "which is for", index_max ,"th node")

    print("\nDegree Distribution:")
    for degree, count in zip(degrees, counts):
        print(f"Degree {degree}: Count {count}")

    plt.bar(degrees, counts, width=1.0, edgecolor='black')
    plt.xlabel('Degree')
    plt.ylabel('Count')
    plt.title('Degree Distribution')
    plt.show()

    print("\n Distribution probability:")
    for degree, prob in zip(degrees, pmf):
        print(f"Degree {degree}: Probability {prob}")

    mu, std = norm.fit(degrees)
    xmin, xmax = min(degrees), max(degrees)
    x = np.linspace(xmin, xmax, 100)
    p = norm.pdf(x, mu, std)
    plt.plot(x, p, 'k', linewidth=2)
    ks_statistic, p_value = stats.kstest(degrees, 'norm', args=(mu, std))

    print("\nDegree Distribution Statistics:")
    print(f"Mean: {mu}")
    print(f"Standard Deviation: {std}")
    print(f"K-S Statistic: {ks_statistic}")
    print(f"P-Value: {p_value}")

    plt.bar(degrees, pmf, width=1.0, edgecolor='black')
    plt.xlabel('Degree')
    plt.ylabel('Probability')
    plt.title('Degree Distribution')
    plt.show()

    print("\nNeighbor Degree Distribution of Random Node(repeated 5 times for better result and undrestanding):")
    random_node = random.choice(list(my_graph.nodes))
    neighbor_degrees, neighbor_counts = neighbor_degree_distribution(my_graph, random_node)
    print("The random node number is:" , int(random_node))
    for degree, count in zip(neighbor_degrees, neighbor_counts):
        print(f"Degree {degree}: Count {count}")
    plt.bar(neighbor_degrees, neighbor_counts, width=1.0, edgecolor='black')
    plt.xlabel('Neighbor degrees')
    plt.ylabel('Neighbor counts')
    plt.title('Neighbor Degree Distribution')
    plt.show()


    random_node = random.choice(list(my_graph.nodes))
    neighbor_degrees, neighbor_counts = neighbor_degree_distribution(my_graph, random_node)
    print("The random node number is:" , int(random_node))
    for degree, count in zip(neighbor_degrees, neighbor_counts):
        print(f"Degree {degree}: Count {count}")
    plt.bar(neighbor_degrees, neighbor_counts, width=1.0, edgecolor='black')
    plt.xlabel('Neighbor degrees')
    plt.ylabel('Neighbor counts')
    plt.title('Neighbor Degree Distribution')
    plt.show()

    random_node = random.choice(list(my_graph.nodes))
    neighbor_degrees, neighbor_counts = neighbor_degree_distribution(my_graph, random_node)
    print("The random node number is:" , int(random_node))
    for degree, count in zip(neighbor_degrees, neighbor_counts):
        print(f"Degree {degree}: Count {count}")
    plt.bar(neighbor_degrees, neighbor_counts, width=1.0, edgecolor='black')
    plt.xlabel('Neighbor degrees')
    plt.ylabel('Neighbor counts')
    plt.title('Neighbor Degree Distribution')
    plt.show()

    random_node = random.choice(list(my_graph.nodes))
    neighbor_degrees, neighbor_counts = neighbor_degree_distribution(my_graph, random_node)
    print("The random node number is:" , int(random_node))
    for degree, count in zip(neighbor_degrees, neighbor_counts):
        print(f"Degree {degree}: Count {count}")
    plt.bar(neighbor_degrees, neighbor_counts, width=1.0, edgecolor='black')
    plt.xlabel('Neighbor degrees')
    plt.ylabel('Neighbor counts')
    plt.title('Neighbor Degree Distribution')
    plt.show()

    random_node = random.choice(list(my_graph.nodes))
    neighbor_degrees, neighbor_counts = neighbor_degree_distribution(my_graph, random_node)
    print("The random node number is:" , int(random_node))
    for degree, count in zip(neighbor_degrees, neighbor_counts):
        print(f"Degree {degree}: Count {count}")
    plt.bar(neighbor_degrees, neighbor_counts, width=1.0, edgecolor='black')
    plt.xlabel('Neighbor degrees')
    plt.ylabel('Neighbor counts')
    plt.title('Neighbor Degree Distribution')
    plt.show()


if __name__ == "__main__":
    main()